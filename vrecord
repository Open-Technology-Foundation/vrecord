#!/usr/bin/env bash
#shellcheck disable=SC2155,SC1090,SC1091,SC2119,SC2120,SC2034
# vrecord - Voice Recorder with Resume Capability
# Copyright (C) 2024-2025 Open Technology Foundation
# License: GPL-3.0-or-later <https://gnu.org/licenses/gpl.html>
#
# Command-line voice recorder for Linux with:
#   - Pause/resume via SIGSTOP/SIGCONT signals
#   - Continue/append to existing WAV recordings
#   - Automatic MP3 conversion (libmp3lame)
#   - Optional transcription integration
#
# Dependencies: ffmpeg (PulseAudio), pactl | Optional: mediainfo, transcribe
#
set -euo pipefail
shopt -s inherit_errexit shift_verbose extglob nullglob

# Script metadata
declare -r VERSION=1.0.0
#shellcheck disable=SC2155
declare -r SCRIPT_PATH=$(realpath -- "$0")
declare -r SCRIPT_DIR=${SCRIPT_PATH%/*} SCRIPT_NAME=${SCRIPT_PATH##*/}

# ============================================================================
# LOGGING AND OUTPUT
# Provides colored, level-based messaging (info/warn/error/debug/success)
# ============================================================================
declare -i VERBOSE=1 DEBUG=0
# Standard colours
if [[ -t 2 ]]; then
  declare -r RED=$'\033[0;31m' GREEN=$'\033[0;32m' YELLOW=$'\033[0;33m' CYAN=$'\033[0;36m' NC=$'\033[0m'
else
  declare -r RED='' GREEN='' YELLOW='' CYAN='' NC=''
fi
# Core message function using FUNCNAME for context
_msg() {
  local -- prefix="$SCRIPT_NAME:" msg
  case ${FUNCNAME[1]} in
    success) prefix+=" ${GREEN}✓${NC}" ;;
    warn)    prefix+=" ${YELLOW}⚡${NC}" ;;
    info)    prefix+=" ${CYAN}◉${NC}" ;;
    error)   prefix+=" ${RED}✗${NC}" ;;
    debug)   prefix+=" ${YELLOW}DEBUG${NC}:" ;;
    *)       ;;
  esac
  for msg in "$@"; do printf '%s %s\n' "$prefix" "$msg"; done
}
# Conditional output based on verbosity
vecho() { ((VERBOSE)) || return 0; _msg "$@"; }
success() { ((VERBOSE)) || return 0; >&2 _msg "$@"; }
warn() { ((VERBOSE)) || return 0; >&2 _msg "$@"; }
info() { ((VERBOSE)) || return 0; >&2 _msg "$@"; }
debug() { ((DEBUG)) || return 0; >&2 _msg "$@"; }
# Unconditional output
error() { >&2 _msg "$@"; }
die() { (($# < 2)) || error "${@:2}"; exit "${1:-0}"; }

# ============================================================================
# SECURITY AND VALIDATION
# Input sanitization to prevent path traversal, injection, and shell exploits
# ============================================================================

# validate_safe_filename: Reject filenames with dangerous characters or patterns
# Rules: alphanumeric, dots, underscores, hyphens only; no leading dash; no ..
# Args: $1=filename, $2=allow_path (0=filename only, 1=allow /)
validate_safe_filename() {
  local -- filename=$1
  local -i allow_path=${2:-0}  # Allow paths with slashes

  # Check for empty filename
  if [[ -z "$filename" ]]; then
    error 'Filename cannot be empty'
    return 1
  fi

  # Check length (255 for filename, longer for full paths)
  local -i max_length=255
  ((allow_path==0)) || max_length=4096
  if ((${#filename} > max_length)); then
    error "Filename too long (max $max_length characters)"
    return 1
  fi

  # Check for directory traversal
  if [[ "$filename" =~ \.\. ]]; then
    error 'Directory traversal not allowed in filename'
    return 1
  fi

  # Check for null bytes
  if [[ "$filename" != "${filename//$'\x00'/}" ]]; then
    error 'Null bytes not allowed in filename'
    return 1
  fi

  # Validate characters based on whether paths are allowed
  if ((allow_path)); then
    # Allow alphanumeric, dots, underscores, hyphens, and forward slashes
    if [[ "$filename" =~ [^a-zA-Z0-9._/-] ]]; then
      error 'Unsafe characters in filename. Only alphanumeric, dots, underscores, hyphens and slashes allowed.'
      return 1
    fi
  else
    # Disallow slashes for pure filenames
    if [[ "$filename" =~ [^a-zA-Z0-9._-] ]]; then
      error 'Unsafe characters in filename. Only alphanumeric, dots, underscores and hyphens allowed.'
      return 1
    fi
  fi

  # Check for shell metacharacters and other dangerous characters
  if [[ "$filename" =~ [\$\`\(\)\{\}\[\]\<\>\|\&\;\'\"\*\?\\] ]]; then
    error 'Shell metacharacters not allowed in filename'
    return 1
  fi

  # Check for leading dash (could be interpreted as option)
  if [[ "$filename" =~ ^- ]]; then
    error 'Filename cannot start with dash'
    return 1
  fi

  return 0
}

# validate_recording_path: Ensure file path is within RECORDING_DIR
# Prevents directory traversal attacks by comparing canonical paths
validate_recording_path() {
  local -- filepath=$1

  # Get absolute paths for comparison
  local -- abs_path abs_recording_dir
  abs_path=$(realpath -- "$filepath" 2>/dev/null) || abs_path="$filepath"
  abs_recording_dir=$(realpath -- "$RECORDING_DIR" 2>/dev/null) || abs_recording_dir=$(realpath "$RECORDING_DIR" 2>/dev/null) || abs_recording_dir="$RECORDING_DIR"

  # Must be under RECORDING_DIR
  if [[ "$abs_path" != "$abs_recording_dir"/* ]] && [[ "$abs_path" != "$abs_recording_dir" ]]; then
    error "File must be within recording directory ${RECORDING_DIR@Q}"
    return 1
  fi

  return 0
}

# ============================================================================
# CONFIGURATION
# Settings with defaults; overridden by config files, then VRECORD_* env vars
# ============================================================================

# Recording parameters - directory paths and audio settings
declare -- RECORDING_DIR=${RECORDING_DIR:-$HOME/Recordings}  # Where WAV/MP3 files are saved
declare -- STATE_DIR=${STATE_DIR:-$HOME/.vrecord}            # Persistent state (config, beep.mp3)
declare -- DEFAULT_PREFIX=${DEFAULT_PREFIX:-voice_recording} # Filename prefix when none specified
declare -- MP3_BITRATE=${MP3_BITRATE:-192k}                  # libmp3lame bitrate
declare -- AUDIO_FORMAT=${AUDIO_FORMAT:-pcm_s16le}           # WAV codec (16-bit PCM)
declare -i SAMPLE_RATE=${SAMPLE_RATE:-44100}                 # Audio sample rate (Hz)
declare -i CHANNELS=${CHANNELS:-2}                           # Mono (1) or stereo (2)
declare -i MIN_DISK_SPACE_MB=${MIN_DISK_SPACE_MB:-100}       # Minimum free space to start
declare -i LOG_MAX_SIZE_MB=${LOG_MAX_SIZE_MB:-10}            # Rotate logs when exceeded
declare -i LOG_MAX_FILES=${LOG_MAX_FILES:-5}                 # Keep N rotated log files

# Beep notifications - periodic audio reminder during recording
declare -i BEEP_ENABLED=${BEEP_ENABLED:-1}                   # 1=enabled, 0=disabled
declare -i BEEP_INTERVAL=${BEEP_INTERVAL:-60}                # Seconds between beeps
declare -- BEEP_FILE="${BEEP_FILE:-$STATE_DIR/beep.mp3}"     # Sound file path

# Runtime state - initialized during execution
declare -- TEMP_DIR=''  # Session temp dir: /tmp/vrecord.XXXXXX
declare -- PID_FILE STATE_FILE SEGMENT_COUNT_FILE SEGMENTS_DIR LOCK_FILE BEEP_PID_FILE

# Command-line flags - set by option parsing
declare -i NO_MP3=0      # --no-mp3: skip MP3 conversion
declare -i NO_BEEP=0     # --no-beep: suppress beep notifications
declare -i TRANSCRIBE=0  # --transcribe: run transcription after MP3

# load_config: Source a config file if it exists and is valid
load_config() {
  local -- config_file=$1
  if [[ -f "$config_file" ]]; then
    debug "Loading config from ${config_file@Q}"
    # Validate syntax in subshell before sourcing
    if (source "$config_file" 2>/dev/null); then
      source "$config_file"
    else
      warn "Invalid config file ${config_file@Q}"
    fi
  fi
}

# Configuration precedence (highest to lowest):
#   1. VRECORD_* environment variables
#   2. User config: ~/.vrecord/config
#   3. System config: /etc/vrecord/config
#   4. Built-in defaults (above)
load_config /etc/vrecord/config
load_config "$STATE_DIR"/config

# Environment variable overrides (VRECORD_* prefix)
RECORDING_DIR="${VRECORD_RECORDING_DIR:-$RECORDING_DIR}"
STATE_DIR="${VRECORD_STATE_DIR:-$STATE_DIR}"
DEFAULT_PREFIX="${VRECORD_DEFAULT_PREFIX:-$DEFAULT_PREFIX}"
MP3_BITRATE="${VRECORD_MP3_BITRATE:-$MP3_BITRATE}"

# Derived paths
LOCK_FILE="$STATE_DIR"/vrecord.lock

# Create directories if they don't exist
mkdir -p "$RECORDING_DIR" "$STATE_DIR"

# ============================================================================
# DEPENDENCY CHECKS
# Verify required tools (ffmpeg with PulseAudio, pactl) are available
# ============================================================================
check_dependencies() {
  local -i missing=0
  
  if ! command -v ffmpeg >/dev/null 2>&1; then
    error 'ffmpeg is not installed!'
    missing+=1
  elif ! ffmpeg -hide_banner -devices 2>&1 | grep -q 'pulse'; then
    error 'ffmpeg does not have PulseAudio support!'
    missing+=1
  fi
  
  if ! command -v pactl >/dev/null 2>&1; then
    error 'PulseAudio is not installed!'
    missing+=1
  fi
  
  ((missing == 0)) || die 1 'Missing dependencies. Please install required software.'
}

# ============================================================================
# LOCK FILE MANAGEMENT
# Prevents concurrent vrecord instances via exclusive file locking
# ============================================================================

# acquire_lock: Obtain exclusive lock using flock (preferred) or atomic mv
# Uses flock(1) for file descriptor locking when available; falls back to
# atomic rename operations with stale lock detection for portability
# Args: $1=timeout_seconds (default: 5)
acquire_lock() {
  local -i timeout=${1:-5}
  
  # Ensure lock directory exists
  local -- lock_dir=${LOCK_FILE%/*}
  [[ -d "$lock_dir" ]] || mkdir -p "$lock_dir" || {
    error "Cannot create lock directory ${lock_dir@Q}"
    return 1
  }
  
  if command -v flock >/dev/null 2>&1; then
    # Use flock for atomic locking via file descriptor
    debug 'Using flock for lock management'

    # Open file descriptor 9 for the lock file
    exec 9>"$LOCK_FILE" || {
      error "Cannot open lock file ${LOCK_FILE@Q}"
      return 1
    }

    # Try to acquire exclusive lock with timeout
    if flock -n -w "$timeout" 9; then
      # Write PID to lock file for debugging/stale detection
      echo $$ > "$LOCK_FILE"
      debug 'Lock acquired using flock'
      return 0
    else
      exec 9>&-  # Close file descriptor on failure
      error "Another instance is running (timeout after ${timeout}s)"
      return 1
    fi
  else
    # Fallback: Use atomic file operations
    debug 'Using atomic file operations for lock management'

    local -- temp_lock="$LOCK_FILE.$$"
    local -i elapsed=0

    # Write PID to temp file
    echo $$ > "$temp_lock" 2>/dev/null || {
      error 'Cannot create temporary lock file'
      return 1
    }

    # Try to acquire lock with timeout
    while ((elapsed < timeout)); do
      # Try atomic move (only succeeds if target doesn't exist)
      if mv -n "$temp_lock" "$LOCK_FILE" 2>/dev/null; then
        debug 'Lock acquired using atomic move'
        return 0
      fi

      # Check if existing lock is stale
      local -- lock_pid=$(cat "$LOCK_FILE" 2>/dev/null)
      if [[ -n "$lock_pid" ]] && ! kill -0 "$lock_pid" 2>/dev/null; then
        warn "Removing stale lock file (PID: $lock_pid)"
        rm -f "$LOCK_FILE"
        # Recreate temp file if needed
        [[ -f "$temp_lock" ]] || echo $$ > "$temp_lock" 2>/dev/null
        continue
      fi

      sleep 1
      elapsed+=1
    done

    # Cleanup temp file
    rm -f "$temp_lock"

    error "Another instance is running (PID: $(cat "$LOCK_FILE" 2>/dev/null || echo 'unknown'))"
    return 1
  fi
}

release_lock() {
  if [[ -f "$LOCK_FILE" ]]; then
    local -- lock_pid=$(cat "$LOCK_FILE" 2>/dev/null)
    if [[ "$lock_pid" == "$$" ]]; then
      rm -f "$LOCK_FILE"
      debug 'Lock released'
    else
      warn "Not releasing lock - owned by different process (PID: $lock_pid)"
    fi
  fi
}

# ============================================================================
# CLEANUP AND SIGNAL HANDLING
# Graceful shutdown: release locks, preserve active recordings if running
# ============================================================================
cleanup_on_exit() {
  local -- exit_code=$?
  
  # If we have an active recording PID, try to save it gracefully
  if [[ -n "$TEMP_DIR" && -f "$TEMP_DIR"/ffmpeg.pid ]]; then
    local -- pid=$(cat "$TEMP_DIR"/ffmpeg.pid 2>/dev/null)
    if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
      warn 'Recording continues in background'
      warn "Use '$SCRIPT_NAME stop' to stop recording"
    fi
  fi
  
  release_lock
  
  # Only clean up temp dir if no active recording
  if [[ -n "$TEMP_DIR" && -d "$TEMP_DIR" ]] && [[ ! -f "$TEMP_DIR"/ffmpeg.pid ]]; then
    rm -rf "$TEMP_DIR"
  fi
  
  exit $exit_code
}

# Signal handlers
handle_signal() {
  local -- signal=$1
  warn "Received signal $signal"
  cleanup_on_exit
}

# Set up traps
trap cleanup_on_exit EXIT
trap 'handle_signal INT' INT
trap 'handle_signal TERM' TERM

# ============================================================================
# STATE MANAGEMENT
# Track recording sessions via temp directory with state files:
#   ffmpeg.pid, state, segment_count, current_file, main_file, segments/
# ============================================================================
get_recording_dir() {
  local -- current_recording="$STATE_DIR"/current_recording
  if [[ -f "$current_recording" ]]; then
    cat "$current_recording"
  else
    echo
  fi
}

# Function to set current recording temp dir
set_recording_dir() {
  local -- dir=$1
  echo "$dir" > "$STATE_DIR"/current_recording
}

# Function to clear current recording
clear_recording_dir() {
  rm -f "$STATE_DIR"/current_recording
}

# init_temp_dir: Initialize or retrieve temporary directory for recording
init_temp_dir() {
  TEMP_DIR=$(get_recording_dir)
  if [[ -z "$TEMP_DIR" || ! -d "$TEMP_DIR" ]]; then
    TEMP_DIR=$(mktemp -d /tmp/"$SCRIPT_NAME".XXXXXX)
    set_recording_dir "$TEMP_DIR"
  fi
  
  PID_FILE="$TEMP_DIR"/ffmpeg.pid
  STATE_FILE="$TEMP_DIR"/state
  SEGMENT_COUNT_FILE="$TEMP_DIR"/segment_count
  SEGMENTS_DIR="$TEMP_DIR"/segments
  BEEP_PID_FILE="$TEMP_DIR"/beep.pid
  TRANSCRIBE_FILE="$TEMP_DIR"/transcribe
  
  mkdir -p "$SEGMENTS_DIR"
}

# ============================================================================
# UTILITY FUNCTIONS
# Disk space checks, timestamp generation, file listing, process validation
# ============================================================================
check_disk_space() {
  local -- path=$1
  local -i required_mb="${2:-$MIN_DISK_SPACE_MB}"  # Use configured minimum
  
  local -i available_mb=$(df -BM "$path" | awk 'NR==2 {print $4}' | sed 's/M//')
  
  if ((available_mb < required_mb)); then
    error "Insufficient disk space: ${available_mb}MB available, ${required_mb}MB required"
    return 1
  fi
  
  return 0
}

# Function to get timestamp for filename
get_timestamp() { date +"%Y%m%d_%H%M%S"; }

# list_recordings: Display WAV files or all files in recordings directory
list_recordings() {
  local -i show_all=${1:-0}
  
  if ((show_all)); then
    printf '%s\n' "All files in $RECORDING_DIR:"
  else
    printf '%s\n' "Available recordings in $RECORDING_DIR:"
  fi
  printf '%s\n' '----------------------------------------'
  
  local -i count=1
  local -i found=0
  local -- file basename size date ext
  
  if ((show_all)); then
    # Show all files
    for file in "$RECORDING_DIR"/*; do
      if [[ -f "$file" ]]; then
        found=1
        basename=$(basename "$file")
        size=$(du -h "$file" | cut -f1)
        date=$(stat -c %y "$file" | cut -d' ' -f1,2 | cut -d'.' -f1)
        ext="${basename##*.}"
        printf "%2d. %-40s [%s] %-8s %s\n" "$count" "$basename" "$size" "[$ext]" "$date"
        count+=1
      fi
    done
  else
    # Show only WAV files
    if ls "$RECORDING_DIR"/*.wav >/dev/null 2>&1; then
      found=1
      for file in "$RECORDING_DIR"/*.wav; do
        basename=$(basename "$file")
        size=$(du -h "$file" | cut -f1)
        date=$(stat -c %y "$file" | cut -d' ' -f1,2 | cut -d'.' -f1)
        printf "%2d. %-40s [%s] %s\n" "$count" "$basename" "$size" "$date"
        count+=1
      done
    fi
  fi
  
  if ((found == 0)); then
    if ((show_all)); then
      printf '%s\n' 'No files found.'
    else
      printf '%s\n' 'No recordings found.'
    fi
  fi
  echo
}

# validate_ffmpeg_process: Check if PID is a running ffmpeg process
validate_ffmpeg_process() {
  local -- pid=$1
  
  # Check if process exists
  if ! kill -0 "$pid" 2>/dev/null; then
    return 1
  fi
  
  # Check if it's actually ffmpeg
  local -- cmd=$(ps -p "$pid" -o comm= 2>/dev/null || echo '')
  if [[ "$cmd" != ffmpeg ]]; then
    return 1
  fi
  
  return 0
}

# get_last_recording: Find the most recently modified WAV file
get_last_recording() {
  local -- last_file
  # Using find instead of ls for better handling of special characters in filenames
  last_file=$(find "$RECORDING_DIR" -maxdepth 1 -name "*.wav" -type f -printf '%T@ %p\n' 2>/dev/null | sort -nr | head -n1 | cut -d' ' -f2-)
  if [[ -n "$last_file" && -f "$last_file" ]]; then
    echo "$last_file"
  else
    echo
  fi
}

# ============================================================================
# LOG MANAGEMENT
# Rotate and cleanup ffmpeg/merge logs to prevent unbounded growth
# ============================================================================
rotate_log() {
  local -- log_file=$1
  local -i max_size_bytes=$((LOG_MAX_SIZE_MB * 1024 * 1024))
  
  # Check if log file exists and size
  if [[ ! -f "$log_file" ]]; then
    return 0
  fi
  
  local -i file_size=$(stat -c%s "$log_file" 2>/dev/null || echo 0)
  
  if ((file_size >= max_size_bytes)); then
    debug "Rotating log file: $log_file (size: $file_size bytes)"
    
    # Rotate existing numbered logs
    local -i i
    for ((i=LOG_MAX_FILES-1; i>=1; i-=1)); do
      if [[ -f "$log_file.$i.gz" ]]; then
        if ((i >= LOG_MAX_FILES-1)); then
          rm -f "$log_file.$i.gz"
        else
          mv "$log_file.$i.gz" "$log_file.$((i+1)).gz"
        fi
      fi
    done
    
    # Compress and rotate current log
    if command -v gzip >/dev/null 2>&1; then
      gzip -c "$log_file" > "$log_file.1.gz" && : > "$log_file"
    else
      mv "$log_file" "$log_file.1" && : > "$log_file"
    fi
  fi
}

# clean_old_logs: Remove old log files from state directory
clean_old_logs() {
  # Skip if STATE_DIR doesn't exist
  [[ -d "$STATE_DIR" ]] || return 0
  
  local -- log_dir="$STATE_DIR"/logs
  
  if [[ -d "$log_dir" ]]; then
    # Find and remove log files older than 30 days
    find "$log_dir" -name "*.log*" -type f -mtime +30 -delete 2>/dev/null || true
  fi
  
  # Clean up old temporary directories
  find "$STATE_DIR" -name 'vrecord.*' -type d -mtime +7 -exec rm -rf {} + 2>/dev/null || true
}

# check_log_before_write: Check and rotate log before writing
check_log_before_write() {
  local -- log_file=$1
  
  # Create log directory if needed
  local -- log_dir=${log_file%/*}
  [[ -d "$log_dir" ]] || mkdir -p "$log_dir"
  
  # Rotate if needed
  rotate_log "$log_file"
}

# ============================================================================
# BEEP NOTIFICATIONS
# Periodic audio reminders during active recording (via ffplay)
# ============================================================================
beep_loop() {
  # Check if beep is enabled
  if ((BEEP_ENABLED == 0 || NO_BEEP == 1)); then
    return 0
  fi
  
  # Search for beep file in multiple locations
  local -a beep_locations=(
    "$BEEP_FILE"  # User configured location
    "$STATE_DIR"/beep.mp3  # User's state directory
    /usr/local/share/vrecord/beep.mp3  # System installation
    /usr/share/vrecord/beep.mp3  # Alternative system location
    "${SCRIPT_PATH%/*}"/beep.mp3  # Same directory as script
  )

  local -i found=0
  local -- location
  for location in "${beep_locations[@]}"; do
    if [[ -f "$location" ]]; then
      BEEP_FILE="$location"
      found=1
      debug "Using beep file ${BEEP_FILE@Q}"
      break
    fi
  done

  if ((found == 0)); then
    debug 'Beep file not found in any standard location'
    return 0
  fi
  
  # Check if ffplay is available
  if ! command -v ffplay >/dev/null 2>&1; then
    debug 'ffplay not found, beep notifications disabled'
    return 0
  fi
  
  # Main beep loop
  while true; do
    # Check if we should continue (recording state)
    if [[ -f "$STATE_FILE" ]]; then
      local -- state=$(cat "$STATE_FILE" 2>/dev/null || echo 'unknown')
      if [[ "$state" != recording ]]; then
        # Not recording, wait and check again
        sleep 5
        continue
      fi
    else
      # No state file, exit
      break
    fi
    
    # Play the beep
    ffplay -nodisp -autoexit -loglevel quiet "$BEEP_FILE" >/dev/null 2>&1 || true
    
    # Sleep for the interval
    sleep "$BEEP_INTERVAL"
  done
}

# start_beep_process: Start the beep notification background process
start_beep_process() {
  # Check if beep is enabled
  if ((BEEP_ENABLED == 0 || NO_BEEP == 1)); then
    return 0
  fi
  
  # Check if already running
  if [[ -f "$BEEP_PID_FILE" ]]; then
    local -- pid=$(cat "$BEEP_PID_FILE" 2>/dev/null)
    if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
      debug "Beep process already running: $pid"
      return 0
    fi
  fi
  
  # Start beep loop in background
  beep_loop &
  local -- beep_pid=$!
  echo "$beep_pid" > "$BEEP_PID_FILE"
  debug "Started beep process: $beep_pid"
}

# stop_beep_process: Stop the beep notification background process
stop_beep_process() {
  if [[ -f "$BEEP_PID_FILE" ]]; then
    local -- pid=$(cat "$BEEP_PID_FILE" 2>/dev/null)
    if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
      kill "$pid" 2>/dev/null || true
      debug "Stopped beep process: $pid"
    fi
    rm -f "$BEEP_PID_FILE"
  fi
}

# ============================================================================
# RECORDING CONTROL
# Core operations: start, pause, resume, stop, merge, convert
# ============================================================================

# start_recording: Begin new recording or continue an existing WAV file
# New recordings: create ${prefix}_TIMESTAMP.wav in RECORDING_DIR
# Resume/continue: record new segments to TEMP_DIR/segments/, merge on stop
# Args: $1=prefix, $2=resume_file, $3=continue_last_flag
start_recording() {
  local -- filename_prefix=${1:-$DEFAULT_PREFIX}
  local -- resume_file=${2:-}
  local -i continue_last=${3:-0}
  
  # Validate filename prefix if provided and not using continue/resume
  if [[ -n "$filename_prefix" ]] && [[ "$filename_prefix" != "$DEFAULT_PREFIX" ]] && \
     [[ -z "$resume_file" ]] && ((continue_last == 0)); then
    if ! validate_safe_filename "$filename_prefix" 0; then
      return 1
    fi
  fi

  # Validate resume file if provided
  if [[ -n "$resume_file" ]]; then
    if ! validate_safe_filename "$resume_file" 1; then
      return 1
    fi
  fi

  check_dependencies
  acquire_lock || return 1
  init_temp_dir
  
  local -- output_file=''

  # Check disk space
  check_disk_space "$RECORDING_DIR" 100 || return 1

  # Check if directory is writable
  if ! touch "$RECORDING_DIR/.test" 2>/dev/null; then
    error "Recording directory is not writable ${RECORDING_DIR@Q}"
    return 1
  fi
  rm -f "$RECORDING_DIR"/.test

  # Handle continue-last flag
  if ((continue_last)); then
    resume_file=$(get_last_recording)
    if [[ -z "$resume_file" ]]; then
      error 'No recordings found to continue!'
      return 1
    fi
    info "Continuing last recording '$(basename "$resume_file")'"
  fi
  
  # Check if we're resuming an existing file
  if [[ -n "$resume_file" ]]; then
    if [[ -f "$resume_file" ]]; then
      # Validate full path is within recording directory
      if ! validate_recording_path "$resume_file"; then
        return 1
      fi
      # File exists, good to go
      true
    elif [[ -f "$RECORDING_DIR/$resume_file" ]]; then
      resume_file="$RECORDING_DIR/$resume_file"
      # Validate constructed path
      if ! validate_recording_path "$resume_file"; then
        return 1
      fi
    else
      error "File ${resume_file@Q} not found!" \
            "Use 'list' command to see available recordings."
      return 1
    fi
  fi

  if [[ -f "$PID_FILE" ]]; then
    local -- pid=$(cat "$PID_FILE")
    if validate_ffmpeg_process "$pid"; then
      error 'Recording is already in progress!'
      return 1
    else
      warn 'Found stale PID file, cleaning up...'
      rm -f "$PID_FILE"
    fi
  fi

  if [[ -n "$resume_file" ]]; then
    # Resuming existing recording
    output_file="$resume_file"
    info "Resuming recording '$(basename "$output_file")'" \
         "Original file size: $(du -h "$output_file" | cut -f1)"

    # Store the main file path for later merging
    echo "$output_file" > "$TEMP_DIR"/main_file

    # Get or initialize segment count
    local -i segment_count=$(cat "$SEGMENT_COUNT_FILE" 2>/dev/null || echo "0")
    segment_count+=1
    local segment_file="$SEGMENTS_DIR"/segment_"$segment_count".wav

    info "Recording new segment ${segment_file@Q}"

    # Start recording the new segment
    local -- log_file="$TEMP_DIR"/ffmpeg.log
    check_log_before_write "$log_file"
    ffmpeg -f pulse -i default -acodec "$AUDIO_FORMAT" -ar "$SAMPLE_RATE" -ac "$CHANNELS" "$segment_file" \
           </dev/null >/dev/null 2>>"$log_file" &

    echo "$segment_count" > "$SEGMENT_COUNT_FILE"
    echo "$segment_file" > "$TEMP_DIR"/current_file
    
    # Save transcribe flag if set
    if ((TRANSCRIBE == 1)); then
      echo '1' > "$TRANSCRIBE_FILE"
    fi

  else
    # New recording
    local -- timestamp=$(get_timestamp)
    # Clean up prefix: remove trailing underscore to avoid double underscores
    filename_prefix="${filename_prefix%_}"
    output_file="$RECORDING_DIR/${filename_prefix}_$timestamp.wav"
    info 'Starting new recording...' \
         "Output file ${output_file@Q}"

    # Start ffmpeg for new recording
    local -- log_file="$TEMP_DIR"/ffmpeg.log
    check_log_before_write "$log_file"
    ffmpeg -f pulse -i default -acodec "$AUDIO_FORMAT" -ar "$SAMPLE_RATE" -ac "$CHANNELS" "$output_file" \
           </dev/null >/dev/null 2>>"$log_file" &

    echo "0" > "$SEGMENT_COUNT_FILE"
    echo "$output_file" > "$TEMP_DIR"/main_file
    echo "$output_file" > "$TEMP_DIR"/current_file
    [[ ! -d "$SEGMENTS_DIR" ]] || rm -rf "${SEGMENTS_DIR:?}"/*
    
    # Save transcribe flag if set
    if ((TRANSCRIBE == 1)); then
      echo '1' > "$TRANSCRIBE_FILE"
    fi
  fi

  # Save the PID and verify process started
  local -- new_pid=$!
  echo "$new_pid" > "$PID_FILE"
  
  # Verify ffmpeg started successfully
  # Small delay allows ffmpeg to initialize or fail fast
  sleep 0.5
  if ! validate_ffmpeg_process "$new_pid"; then
    error "Failed to start recording! Check $TEMP_DIR/ffmpeg.log for details"
    rm -f "$PID_FILE"
    return 1
  fi
  
  echo 'recording' > "$STATE_FILE"

  info "Recording started. PID: $new_pid" \
       "Use '$SCRIPT_NAME stop' to stop recording"
  
  # Start beep notifications
  start_beep_process
       
  release_lock
}

# pause_recording: Suspend ffmpeg process with SIGSTOP signal
# Recording can be resumed later with SIGCONT via resume_recording()
pause_recording() {
  acquire_lock || return 1
  init_temp_dir
  
  [[ -f "$PID_FILE" ]] || { error 'No active recording found!'; release_lock; return 1; }

  local -- pid=$(cat "$PID_FILE")
  local -- state=$(cat "$STATE_FILE" 2>/dev/null || echo 'unknown')

  if [[ "$state" == paused ]]; then
    error 'Recording is already paused!'
    release_lock
    return 1
  fi

  if validate_ffmpeg_process "$pid"; then
    info 'Pausing recording...'
    kill -STOP "$pid"
    echo 'paused' > "$STATE_FILE"
    
    # Stop beep notifications while paused
    stop_beep_process
    
    info "Recording paused. Use 'resume' to continue."
  else
    error 'Recording process not found!'
    cleanup_files
    release_lock
    return 1
  fi

  release_lock
}

# resume_recording: Continue paused ffmpeg process with SIGCONT signal
resume_recording() {
  acquire_lock || return 1
  init_temp_dir
  
  if [[ ! -f "$PID_FILE" ]]; then
    error 'No active recording found!'
    release_lock
    return 1
  fi

  local -- pid=$(cat "$PID_FILE")
  local -- state=$(cat "$STATE_FILE" 2>/dev/null || echo 'unknown')

  if [[ "$state" == recording ]]; then
    error 'Recording is already active!'
    release_lock
    return 1
  fi

  if validate_ffmpeg_process "$pid"; then
    info 'Resuming recording...'
    kill -CONT "$pid"
    echo 'recording' > "$STATE_FILE"
    
    # Restart beep notifications
    start_beep_process
    
    info 'Recording resumed.'
  else
    error 'Recording process not found!'
    cleanup_files
    release_lock
    return 1
  fi

  release_lock
}

# merge_segments: Combine original file with recorded segments using ffmpeg
# Uses ffmpeg concat demuxer with a filelist.txt containing:
#   file '/path/to/original.wav'
#   file '/path/to/segment_1.wav'
#   ...
# Segments are removed after successful merge; preserved on failure for recovery
merge_segments() {
  local main_file=$1
  local -i segment_count=$(cat "$SEGMENT_COUNT_FILE" 2>/dev/null || echo '0')
  
  ((segment_count)) || return 0  # No segments to merge

  info 'Merging segments with original recording...'

  # Create concat demuxer input file for ffmpeg
  # Format: each line contains "file '/path/to/file.wav'"
  local -- filelist="$TEMP_DIR"/filelist.txt
  echo "file '$main_file'" > "$filelist"

  # Add all segments to the list
  local -i i
  local -- segment_file
  for ((i=1; i<=segment_count; i+=1)); do
    segment_file="$SEGMENTS_DIR"/segment_"$i".wav
    if [[ -f "$segment_file" ]]; then
      echo "file ${segment_file@Q}" >> "$filelist"
    fi
  done

  # Create merged file
  local -- temp_merged="$TEMP_DIR"/merged_$(basename "$main_file")

  local -- log_file="$TEMP_DIR"/merge.log
  check_log_before_write "$log_file"
  if ffmpeg -f concat -safe 0 -i "$filelist" -c copy "$temp_merged" -y \
            </dev/null >/dev/null 2>>"$log_file"; then
    # Replace original with merged version
    mv "$temp_merged" "$main_file"
    info "Successfully merged segments into ${main_file@Q}"

    # Clean up segment files
    rm -f "$SEGMENTS_DIR"/segment_*.wav
    rm -f "$filelist"
  else
    error 'Error: Failed to merge segments!' \
          "Original file preserved: $main_file" \
          "Segments preserved in: $SEGMENTS_DIR" \
          "Check $TEMP_DIR/merge.log for details"
    return 1
  fi
}

# stop_recording: End recording session and finalize output files
# Signal sequence: SIGCONT (if paused) → SIGTERM → wait → SIGKILL (timeout)
# Then: merge segments (if any), convert to MP3 (unless --no-mp3), transcribe (if -t)
stop_recording() {
  acquire_lock || return 1
  init_temp_dir
  
  if [[ ! -f "$PID_FILE" ]]; then
    error 'No active recording found!'
    release_lock
    return 1
  fi

  local -- pid=$(cat "$PID_FILE")
  local -- main_file=$(cat "$TEMP_DIR"/main_file 2>/dev/null)
  local -- current_file=$(cat "$TEMP_DIR"/current_file 2>/dev/null)
  local -i segment_count=$(cat "$SEGMENT_COUNT_FILE" 2>/dev/null || echo '0')

  if validate_ffmpeg_process "$pid"; then
    info 'Stopping recording...'
    
    # Stop beep notifications
    stop_beep_process

    # Resume if paused before stopping
    # This ensures we get a clean shutdown of the recording
    local -- state=$(cat "$STATE_FILE" 2>/dev/null || echo 'unknown')
    if [[ "$state" == "paused" ]]; then
      kill -CONT "$pid" 2>/dev/null
      sleep 0.5  # Allow process to resume
    fi

    # Send SIGTERM to ffmpeg for clean shutdown
    kill -TERM "$pid" 2>/dev/null

    # Wait for process to finish with timeout
    local -i wait_count=0
    while kill -0 "$pid" 2>/dev/null && ((wait_count < 20)); do
      sleep 0.5
      wait_count+=1
    done

    if kill -0 "$pid" 2>/dev/null; then
      warn "Process didn't stop cleanly, forcing..."
      kill -KILL "$pid" 2>/dev/null || true
    fi

    info 'Recording stopped.'

    # If we have segments, merge them
    if ((segment_count > 0)) && [[ -n "$main_file" ]]; then
      merge_segments "$main_file"
    fi

    if [[ -n "$main_file" && -f "$main_file" ]]; then
      info "Recording saved to ${main_file@Q}"

      # Show file info
      if command -v mediainfo >/dev/null 2>&1; then
        info 'File info:'
        mediainfo "$main_file" 2>/dev/null | grep -E "(Duration|File size)" >&2 || true
      else
        info "File size: $(du -h "$main_file" | cut -f1)"
      fi
      
      # Convert to MP3 unless --no-mp3 was specified
      if ((NO_MP3 == 0)) && [[ -n "$main_file" && -f "$main_file" ]]; then
        convert_to_mp3 "$main_file"
      fi
    fi
  else
    error 'Recording process not found!'
    cleanup_files
    release_lock
    return 1
  fi

  cleanup_files
  release_lock
}

# convert_to_mp3: Convert WAV recording to MP3 format
convert_to_mp3() {
  local -- wav_file=$1
  local -- mp3_file="${wav_file%.wav}".mp3
  
  if ! command -v ffmpeg >/dev/null 2>&1; then
    warn "ffmpeg not found, skipping MP3 conversion"
    return 1
  fi
  
  info "Converting to MP3: $(basename -- "$mp3_file")"
  
  local -- log_file="$TEMP_DIR"/mp3_convert.log
  check_log_before_write "$log_file"
  if ffmpeg -y -i "$wav_file" -codec:a libmp3lame -b:a "$MP3_BITRATE" "$mp3_file" \
            </dev/null >/dev/null 2>>"$log_file"; then
    # Wait a moment for file system to sync
    sync
    success "MP3 created: $mp3_file"
    info "MP3 size: $(du -h "$mp3_file" | cut -f1)"
    
    # Run transcription if requested and transcribe command is available
    if [[ -f "$TRANSCRIBE_FILE" ]] || ((TRANSCRIBE == 1)); then
      if command -v transcribe >/dev/null 2>&1; then
        info "Running transcription on: $(basename "$mp3_file")"
        if transcribe "$mp3_file"; then
          success 'Transcription completed'
        else
          warn 'Transcription failed'
        fi
      else
        warn 'Transcribe command not found, skipping transcription'
      fi
    fi
  else
    error 'Failed to convert to MP3' \
          "Check $TEMP_DIR/mp3_convert.log for details"
    return 1
  fi
}

# show_status: Display current recording status and statistics
show_status() {
  init_temp_dir
  
  if [[ -f "$PID_FILE" ]]; then
    local -- pid=$(cat "$PID_FILE")
    local -- state=$(cat "$STATE_FILE" 2>/dev/null || echo 'unknown')
    local -- main_file=$(cat "$TEMP_DIR"/main_file 2>/dev/null)
    local -- current_file=$(cat "$TEMP_DIR"/current_file 2>/dev/null)
    local -i segment_count=$(cat "$SEGMENT_COUNT_FILE" 2>/dev/null || echo '0')

    if validate_ffmpeg_process "$pid"; then
      info "Recording Status: $state" \
           "PID: $pid" \
           "Main file: $main_file"
      if ((segment_count > 0)); then
        info "Resume segments: $segment_count" \
             "Original file size: $(du -h "$main_file" 2>/dev/null | cut -f1 || echo "Unknown")"
        if [[ -f "$current_file" ]]; then
          info "Current segment size: $(du -h "$current_file" 2>/dev/null | cut -f1 || echo "Unknown")"
        fi
      else
        if [[ -f "$current_file" ]]; then
          info "Current file size: $(du -h "$current_file" 2>/dev/null | cut -f1 || echo "Unknown")"
        fi
      fi
      
      # Check for errors in log
      if [[ -f "$TEMP_DIR"/ffmpeg.log ]] && [[ -s "$TEMP_DIR"/ffmpeg.log ]]; then
        local -- last_error=$(tail -n 5 "$TEMP_DIR"/ffmpeg.log 2>/dev/null | grep -i error | tail -n 1)
        [[ -z "$last_error" ]] || warn "Recent error: $last_error"
      fi
    else
      error 'No active recording (stale PID file found)'
      cleanup_files
    fi
  else
    error 'No active recording'
  fi
}

# cleanup_files: Remove all temporary files and clear state
cleanup_files() {
  # Stop beep process if running
  stop_beep_process
  
  rm -f "$PID_FILE" "$STATE_FILE" "$SEGMENT_COUNT_FILE" "$BEEP_PID_FILE" "$TRANSCRIBE_FILE"
  rm -f "$TEMP_DIR"/current_file "$TEMP_DIR"/main_file
  rm -f "$TEMP_DIR"/filelist.txt "$TEMP_DIR"/*.log
  clear_recording_dir
  if [[ -n "$TEMP_DIR" && -d "$TEMP_DIR" ]]; then
    rm -rf "$TEMP_DIR"
  fi
}

# show_help: Display usage information
show_help() {
  cat <<HELP
vrecord - Voice Recorder with Resume Capability

Usage: $SCRIPT_NAME [options] <command> [args]

Commands:
  start [PREFIX]    Start new recording (default prefix: voice_recording)
  start -c          Continue the most recent recording
  start -r FILE     Resume a specific WAV file
  pause             Pause active recording (SIGSTOP)
  resume            Resume paused recording (SIGCONT)
  stop              Stop recording, create MP3
  status            Show recording state and file info
  list [--all]      List WAV files (or all files with --all)
  help              Show this help

Start Options:
  -c, --continue-last   Append to the most recent WAV file
  -r, --resume FILE     Append to a specific WAV file
  -t, --transcribe      Transcribe after MP3 conversion

Stop Options:
  -t, --transcribe      Transcribe the MP3 file

Global Options:
  -n, --no-mp3     Skip MP3 conversion
  -b, --no-beep    Disable periodic beep reminders
  -v, --verbose    Increase output verbosity
  -q, --quiet      Suppress non-error output
  -h, --help       Show this help
  -V, --version    Show version

Examples:
  # Basic workflow
  $SCRIPT_NAME start meeting       # → meeting_20250120_143052.wav
  $SCRIPT_NAME pause               # Pause recording
  $SCRIPT_NAME resume              # Resume recording
  $SCRIPT_NAME stop                # → meeting_20250120_143052.mp3

  # Continue previous recording
  $SCRIPT_NAME start -c            # Append to most recent WAV

  # Record with transcription
  $SCRIPT_NAME start -t notes      # Start with transcribe flag
  $SCRIPT_NAME stop                # Stop, convert, transcribe

  # Skip MP3 conversion
  $SCRIPT_NAME -n start interview  # Record WAV only
  $SCRIPT_NAME stop --no-mp3       # Or specify at stop time

Paths:
  Recordings: $RECORDING_DIR
  State:      $STATE_DIR

Recording continues in background after script exits.
Use 'status' to check state and 'stop' to finalize.
HELP
  exit 0
}


# ============================================================================
# COMMAND-LINE PARSING
# Global options first, then command with command-specific options
# ============================================================================
parse_args() {
  local -a args=()
  local -- command=''

  # Standard argument parsing pattern
  while (($#)); do case $1 in
    -n|--no-mp3)     NO_MP3=1 ;;
    -b|--no-beep)    NO_BEEP=1 ;;
    -v|--verbose)    VERBOSE+=1 ;;
    -q|--quiet)      VERBOSE=0 ;;
    -h|--help|help)  show_help ;;
    -V|--version)    echo "$SCRIPT_NAME $VERSION"
                     cat >&2 <<EOF
Copyright (C) 2024 Open Technology Foundation
License: GPL-3.0-or-later <https://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
EOF
                     exit 0 ;;
    -[nbvqhV]?*)     set -- "${1:0:2}" "-${1:2}" "${@:2}"; continue ;;

    -*)
      # Unknown option - save for command processing
      args+=("$1") ;;
    *)
      # This is the command or a command argument
      if [[ -z "$command" ]]; then
        command=$1
      else
        args+=("$1")
      fi ;;
  esac; shift; done

  # If no command given, show help
  [[ -n "$command" ]] || show_help

  # Process the command with remaining arguments
  process_command "$command" ${args[@]+"${args[@]}"}
}

# process_command: Execute the requested command with its arguments
process_command() {
  local -- command=$1
  shift
  
  case "$command" in
    start)
      local -- prefix=''
      local -- resume_file=''
      local -i continue_last=0

      # Parse start command options
      while (($#)); do
        case "$1" in
          -c|--continue-last)
            continue_last=1 ;;
          -r|--resume)
            [[ -n "${2:-}" ]] || die 2 '--resume requires a filename'
            resume_file=$2
            # Validate resume filename
            validate_safe_filename "$resume_file" 1 || die 2 'Invalid resume filename'
            shift ;;
          -t|--transcribe)
            TRANSCRIBE=1 ;;
          -*)
            die 2 "Unknown option for start: ${1@Q}" ;;
          *)
            # This is the prefix
            [[ -z "$prefix" ]] || die 2 'Too many arguments for start command'
            prefix="$1"
            # Validate prefix
            validate_safe_filename "$prefix" 0 || die 2 'Invalid filename prefix' ;;
      esac; shift; done
      
      # Validate conflicting options
      if ((continue_last)) && [[ -n "$resume_file" ]]; then
        die 2 'Cannot use both --continue-last and --resume'
      fi
      
      # Validation: prefix not allowed with continue/resume
      # When continuing/resuming, the filename is already determined
      if [[ -n "$prefix" ]] && { ((continue_last)) || [[ -n "$resume_file" ]]; }; then
        die 2 'Cannot specify filename prefix when continuing/resuming a recording'
      fi
      
      start_recording "$prefix" "$resume_file" "$continue_last"
      ;;
    pause)
      pause_recording
      ;;
    resume)
      resume_recording
      ;;
    stop)
      # Parse stop command options
      while (($#)); do case $1 in
        -t|--transcribe)  TRANSCRIBE=1 ;;
        -*)               die 2 "Unknown option for stop: ${1@Q}" ;;
        *)                die 2 "Unexpected argument for stop: ${1@Q}" ;;
      esac; shift; done
      stop_recording
      ;;
    status)
      show_status
      ;;
    list)
      local -i show_all=0
      
      # Parse list options
      while (($#)); do case $1 in
        --all)  show_all=1 ;;
        -*)     die 2 "Unknown option for list: ${1@Q}" ;;
        *)      die 2 "Unknown argument for list: ${1@Q}" ;;
      esac; shift; done
      
      list_recordings "$show_all"
      ;;
    *)
      die 2 "Unknown command ${command@Q}. Use '$SCRIPT_NAME help' for usage."
      ;;
  esac
}

# ============================================================================
# MAIN ENTRY POINT
# ============================================================================
main() {
  clean_old_logs
  
  # Parse arguments and execute command
  parse_args "$@"
}

# Execute main function with all command-line arguments
main "$@"
#fin
